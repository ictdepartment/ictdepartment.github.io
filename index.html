<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="styles.css">
  <script>
    function copyText(buttonId, hiddenTextId) {
      // Get the hidden text element
      var hiddenText = document.getElementById(hiddenTextId);

      // Create a textarea element
      var textarea = document.createElement("textarea");

      // Set the value of the textarea to the hidden text
      textarea.value = hiddenText.innerText;

      // Append the textarea to the document
      document.body.appendChild(textarea);

      // Select the contents of the textarea
      textarea.select();

      // Copy the selected text to the clipboard
      document.execCommand("copy");

      // Remove the textarea from the document
      document.body.removeChild(textarea);

      // Alert the user that the text has been copied
      alert("Text has been copied from button: " + buttonId);
    }
  </script>
</head>
<body>
  <button onclick="copyText('button1', 'hiddenText1')">Assignment 1-1 (BFS)</button>
  <button onclick="copyText('button2', 'hiddenText2')">Assignment 1-2 (DFS) </button>
  <button onclick="copyText('button3', 'hiddenText3')">Assignment 2-1 (BUBBLESORT)</button>
  <button onclick="copyText('button4', 'hiddenText4')">Assignment 2-2 (MERGSORT)</button>
  <button onclick="copyText('button5', 'hiddenText5')">Assignment 3 (MINMACAVG)</button>
  </br>
  
 <a href="https://firebasestorage.googleapis.com/v0/b/pract-c61af.appspot.com/o/IMDB.ipynb?alt=media&token=765a18e8-2609-494e-b6a7-f193862da42d" download>IMDB Code</a>
 <a href="https://firebasestorage.googleapis.com/v0/b/pract-c61af.appspot.com/o/IMDB%20Dataset.csv?alt=media&token=e696b2cd-60e6-4e2b-8674-4b0c19c5acb3" download>IMDB Dataset</a>
  <a href="https://firebasestorage.googleapis.com/v0/b/pract-c61af.appspot.com/o/Fashion.ipynb?alt=media&token=641f264f-c1cc-4146-9ab8-46dd5a7d7473" download>FASHION Code</a>
 <a href="https://firebasestorage.googleapis.com/v0/b/pract-c61af.appspot.com/o/fashion-mnist_test.csv?alt=media&token=dcb79495-38a0-4bbe-ac28-9578533cf683" download>FASHION Test Dataset</a>
   <a href="https://firebasestorage.googleapis.com/v0/b/pract-c61af.appspot.com/o/fashion-mnist_train.csv?alt=media&token=2b652b29-a7cf-468d-9094-e2f009f4a90e" download>FASHION Train Dataset</a>
  <a href="https://firebasestorage.googleapis.com/v0/b/pract-c61af.appspot.com/o/boston1.ipynb?alt=media&token=da47c828-23d2-4123-b022-29ae0756b4ca" download>Boston Code</a>
  <div id="hiddenText1" style="display: none;">
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;omp.h&gt;

using namespace std;

void bfs(int node, vector&lt;vector&lt;int&gt;&gt;& graph, vector&lt;bool&gt;& visited) {
    queue&lt;int&gt; q;
    q.push(node);
    visited[node] = true;

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        cout &lt;&lt; "Visited node: " &lt;&lt; curr &lt;&lt; endl;

        #pragma omp parallel for
        for (int i = 0; i &lt; graph[curr].size(); i++) {
            int neighbor = graph[curr][i];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    int numNodes = 7;
    vector&lt;vector&lt;int&gt;&gt; graph(numNodes);
    vector&lt;bool&gt; visited(numNodes, false);

    // Graph initialization
    graph[0] = {1, 2};
    graph[1] = {3, 4};
    graph[2] = {5};
    graph[3] = {};
    graph[4] = {6};
    graph[5] = {2};
    graph[6] = {};

    int startNode = 0;

    cout &lt;&lt; "BFS traversal using OpenMP:" &lt;&lt; endl;
    bfs(startNode, graph, visited);

    return 0;
}

    </pre>
  </div>
  <div id="hiddenText2" style="display: none;">
  <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;omp.h&gt;

using namespace std;

void dfs(int node, vector&lt;vector&lt;int&gt;&gt;& graph, vector&lt;bool&gt;& visited) {
    stack&lt;int&gt; stk;
    stk.push(node);

    while (!stk.empty()) {
        int curr = stk.top();
        stk.pop();

        if (!visited[curr]) {
            visited[curr] = true;
            cout &lt;&lt; "Visited node: " &lt;&lt; curr &lt;&lt; endl;

            #pragma omp parallel for
            for (int i = 0; i &lt; graph[curr].size(); i++) {
                int neighbor = graph[curr][i];
                stk.push(neighbor);
            }
        }
    }
}

int main() {
    int numNodes = 7;
    vector&lt;vector&lt;int&gt;&gt; graph(numNodes);
    vector&lt;bool&gt; visited(numNodes, false);

    // Graph initialization
    graph[0] = {1, 2};
    graph[1] = {3, 4};
    graph[2] = {5};
    graph[3] = {};
    graph[4] = {6};
    graph[5] = {2};
    graph[6] = {};

    int startNode = 0;

    cout &lt;&lt; "DFS traversal using OpenMP:" &lt;&lt; endl;
    dfs(startNode, graph, visited);

    return 0;
}

    </pre>
  </div>
  <div id="hiddenText3" style="display: none;"><pre>
  #include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;omp.h&gt;
using namespace std;
void bubble(int *, int);
void swap(int &, int &);
void bubble(int *a, int n) {
for( int i = 0; i &lt; n; i++ ) {
int first = i % 2;
#pragma omp parallel for shared(a,first)
for( int j = first; j &lt; n-1; j += 2 ) {
if( a[ j ] &gt; a[ j+1 ] ) {
swap( a[ j ], a[ j+1 ] );
}
}
}
}
void swap(int &a, int &b) {
int test;
test=a;
a=b;
b=test;
}
int main() {
int *a,n;
cout&lt;&lt;"\n enter total no of elements=&gt;";
cin&gt;&gt;n;
a=new int[n];
cout&lt;&lt;"\n enter elements=&gt;";
for(int i=0;i&lt;n;i++) {
cin&gt;&gt;a[i];
}
bubble(a,n);
cout&lt;&lt;"\n sorted array is=&gt;";
for(int i=0;i&lt;n;i++) {
cout&lt;&lt;a[i]&lt;&lt;endl;
}
return 0;
}
  
  </pre></div>
  <div id="hiddenText4" style="display: none;"><pre>
#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;omp.h&gt;
using namespace std;

void mergesort(int a[], int i, int j);
void merge(int a[], int i1, int j1, int i2, int j2);

void mergesort(int a[], int i, int j) {
    int mid;
    if (i &lt; j) {
        mid = (i + j) / 2;
#pragma omp parallel sections
        {
#pragma omp section
            {
                mergesort(a, i, mid);
            }
#pragma omp section
            {
                mergesort(a, mid + 1, j);
            }
        }
        merge(a, i, mid, mid + 1, j);
    }
}

void merge(int a[], int i1, int j1, int i2, int j2) {
    int temp[1000];
    int i, j, k;
    i = i1;
    j = i2;
    k = 0;
    while (i &lt;= j1 && j &lt;= j2) {
        if (a[i] &lt; a[j]) {
            temp[k++] = a[i++];
        }
        else {
            temp[k++] = a[j++];
        }
    }
    while (i &lt;= j1) {
        temp[k++] = a[i++];
    }
    while (j &lt;= j2) {
        temp[k++] = a[j++];
    }
    for (i = i1, j = 0; i &lt;= j2; i++, j++) {
        a[i] = temp[j];
    }
}

int main() {
    int* a, n, i;
    cout &lt;&lt; "\nEnter total number of elements: ";
    cin &gt;&gt; n;
    a = new int[n];
    cout &lt;&lt; "\nEnter elements: ";
    for (i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
    mergesort(a, 0, n - 1);
    cout &lt;&lt; "\nSorted array is: ";
    for (i = 0; i &lt; n; i++) {
        cout &lt;&lt; "\n" &lt;&lt; a[i];
    }
    delete[] a;
    return 0;
}


  </pre></div>
  <div id="hiddenText5" style="display: none;"><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;omp.h&gt;
#include &lt;climits&gt;
using namespace std;
void min_reduction(int arr[], int n) {
int min_value = INT_MAX;
#pragma omp parallel for reduction(min: min_value)
for (int i = 0; i &lt; n; i++) {
if (arr[i] &lt; min_value) {
min_value = arr[i];
}
}
cout &lt;&lt; "Minimum value: " &lt;&lt; min_value &lt;&lt; endl;
}
void max_reduction(int arr[], int n) {
int max_value = INT_MIN;
#pragma omp parallel for reduction(max: max_value)
for (int i = 0; i &lt; n; i++) {
if (arr[i] &gt; max_value) {
max_value = arr[i];
}
}
cout &lt;&lt; "Maximum value: " &lt;&lt; max_value &lt;&lt; endl;
}
void sum_reduction(int arr[], int n) {
int sum = 0;
#pragma omp parallel for reduction(+: sum)
for (int i = 0; i &lt; n; i++) {
sum += arr[i];
}
cout &lt;&lt; "Sum: " &lt;&lt; sum &lt;&lt; endl;
}
void average_reduction(int arr[], int n) {
int sum = 0;
#pragma omp parallel for reduction(+: sum)
for (int i = 0; i &lt; n; i++) {
sum += arr[i];
}
cout &lt;&lt; "Average: " &lt;&lt; (double)sum / (n-1) &lt;&lt; endl;
}
int main() {
int *arr,n;
cout&lt;&lt;"\n enter total no of elements=&gt;";
cin&gt;&gt;n;
arr=new int[n];
cout&lt;&lt;"\n enter elements=&gt;";
for(int i=0;i&lt;n;i++) {
cin&gt;&gt;arr[i];
}
// int arr[] = {5, 2, 9, 1, 7, 6, 8, 3, 4};
// int n = size(arr);
min_reduction(arr, n);
max_reduction(arr, n);
sum_reduction(arr, n);
average_reduction(arr, n);
}


  </pre></div>
</body>
</html>
