<!DOCTYPE html>
<html>
<head>
  <title>Department</title>
  <link rel="stylesheet" type="text/css" href="styles.css">
  <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-storage.js"></script>
  <script>
    function a1_1() {
      // Get the hidden text element
      var hiddenText = document.getElementById("hiddenText");

      // Create a textarea element
      var textarea = document.createElement("textarea");

      // Set the value of the textarea to the hidden text
      textarea.value = hiddenText.innerText;

      // Append the textarea to the document
      document.body.appendChild(textarea);

      // Select the contents of the textarea
      textarea.select();

      // Copy the selected text to the clipboard
      document.execCommand("copy");

      // Remove the textarea from the document
      document.body.removeChild(textarea);
      
    function a1_2() {
      // Get the hidden text element
      var hiddenText = document.getElementById("hiddenText1");

      // Create a textarea element
      var textarea = document.createElement("textarea");

      // Set the value of the textarea to the hidden text
      textarea.value = hiddenText.innerText;

      // Append the textarea to the document
      document.body.appendChild(textarea);

      // Select the contents of the textarea
      textarea.select();

      // Copy the selected text to the clipboard
      document.execCommand("copy");

      // Remove the textarea from the document
      document.body.removeChild(textarea);

     
    }
  </script>
</head>

  
<body>
  
  
  
  <button onclick="a1_1()">Assignment1</button>

  <div id="hiddenText" style="display: none;">
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;omp.h&gt;

using namespace std;

void bfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    queue<int> q;
    q.push(node);
    visited[node] = true;

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        cout << "Visited node: " << curr << endl;

        #pragma omp parallel for
        for (int i = 0; i < graph[curr].size(); i++) {
            int neighbor = graph[curr][i];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    int numNodes = 7;
    vector<vector<int>> graph(numNodes);
    vector<bool> visited(numNodes, false);

    // Graph initialization
    graph[0] = {1, 2};
    graph[1] = {3, 4};
    graph[2] = {5};
    graph[3] = {};
    graph[4] = {6};
    graph[5] = {2};
    graph[6] = {};

    int startNode = 0;

    cout << "BFS traversal using OpenMP:" << endl;
    bfs(startNode, graph, visited);

    return 0;
}</pre>
  </div>
  *************************************
  
  
  
   <button onclick="a1_2()">Assignment1-2</button>

  <div id="hiddenText1" style="display: none;">
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;omp.h&gt;

using namespace std;

void dfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    stack<int> stk;
    stk.push(node);

    while (!stk.empty()) {
        int curr = stk.top();
        stk.pop();

        if (!visited[curr]) {
            visited[curr] = true;
            cout << "Visited node: " << curr << endl;

            #pragma omp parallel for
            for (int i = 0; i < graph[curr].size(); i++) {
                int neighbor = graph[curr][i];
                stk.push(neighbor);
            }
        }
    }
}

int main() {
    int numNodes = 7;
    vector<vector<int>> graph(numNodes);
    vector<bool> visited(numNodes, false);

    // Graph initialization
    graph[0] = {1, 2};
    graph[1] = {3, 4};
    graph[2] = {5};
    graph[3] = {};
    graph[4] = {6};
    graph[5] = {2};
    graph[6] = {};

    int startNode = 0;

    cout << "DFS traversal using OpenMP:" << endl;
    dfs(startNode, graph, visited);

    return 0;
}</pre>
  </div>
  *************************************
  
  
  
  
  
  
  
 <pre>

*****************************************************************


<b>3. ASSIGNMENT2BUBBLESORT</b>

#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;omp.h&gt;
using namespace std;
void bubble(int *, int);
void swap(int &, int &);
void bubble(int *a, int n) {
for( int i = 0; i < n; i++ ) {
int first = i % 2;
#pragma omp parallel for shared(a,first)
for( int j = first; j < n-1; j += 2 ) {
if( a[ j ] > a[ j+1 ] ) {
swap( a[ j ], a[ j+1 ] );
}
}
}
}
void swap(int &a, int &b) {
int test;
test=a;
a=b;
b=test;
}
int main() {
int *a,n;
cout<<"\n enter total no of elements=>";
cin>>n;
a=new int[n];
cout<<"\n enter elements=>";
for(int i=0;i<n;i++) {
cin>>a[i];
}
bubble(a,n);
cout<<"\n sorted array is=>";
for(int i=0;i<n;i++) {
cout<<a[i]<<endl;
}
return 0;
}

********************************************************************************

<b>4. ASSIGNMENT2MERGESORT</b>

#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;omp.h&gt;
using namespace std;

void mergesort(int a[], int i, int j);
void merge(int a[], int i1, int j1, int i2, int j2);

void mergesort(int a[], int i, int j) {
    int mid;
    if (i < j) {
        mid = (i + j) / 2;
#pragma omp parallel sections
        {
#pragma omp section
            {
                mergesort(a, i, mid);
            }
#pragma omp section
            {
                mergesort(a, mid + 1, j);
            }
        }
        merge(a, i, mid, mid + 1, j);
    }
}

void merge(int a[], int i1, int j1, int i2, int j2) {
    int temp[1000];
    int i, j, k;
    i = i1;
    j = i2;
    k = 0;
    while (i <= j1 && j <= j2) {
        if (a[i] < a[j]) {
            temp[k++] = a[i++];
        }
        else {
            temp[k++] = a[j++];
        }
    }
    while (i <= j1) {
        temp[k++] = a[i++];
    }
    while (j <= j2) {
        temp[k++] = a[j++];
    }
    for (i = i1, j = 0; i <= j2; i++, j++) {
        a[i] = temp[j];
    }
}

int main() {
    int* a, n, i;
    cout << "\nEnter total number of elements: ";
    cin >> n;
    a = new int[n];
    cout << "\nEnter elements: ";
    for (i = 0; i < n; i++) {
        cin >> a[i];
    }
    mergesort(a, 0, n - 1);
    cout << "\nSorted array is: ";
    for (i = 0; i < n; i++) {
        cout << "\n" << a[i];
    }
    delete[] a;
    return 0;
}


**************************************************************************************************
<b>5. ASSIGNMENT3MINMAXSUMANDAVERAGE</b>

#include <iostream>
//#include <vector>
#include <omp.h>
#include <climits>
using namespace std;
void min_reduction(int arr[], int n) {
int min_value = INT_MAX;
#pragma omp parallel for reduction(min: min_value)
for (int i = 0; i < n; i++) {
if (arr[i] < min_value) {
min_value = arr[i];
}
}
cout << "Minimum value: " << min_value << endl;
}
void max_reduction(int arr[], int n) {
int max_value = INT_MIN;
#pragma omp parallel for reduction(max: max_value)
for (int i = 0; i < n; i++) {
if (arr[i] > max_value) {
max_value = arr[i];
}
}
cout << "Maximum value: " << max_value << endl;
}
void sum_reduction(int arr[], int n) {
int sum = 0;
#pragma omp parallel for reduction(+: sum)
for (int i = 0; i < n; i++) {
sum += arr[i];
}
cout << "Sum: " << sum << endl;
}
void average_reduction(int arr[], int n) {
int sum = 0;
#pragma omp parallel for reduction(+: sum)
for (int i = 0; i < n; i++) {
sum += arr[i];
}
cout << "Average: " << (double)sum / (n-1) << endl;
}
int main() {
int *arr,n;
cout<<"\n enter total no of elements=>";
cin>>n;
arr=new int[n];
cout<<"\n enter elements=>";
for(int i=0;i<n;i++) {
cin>>arr[i];
}
// int arr[] = {5, 2, 9, 1, 7, 6, 8, 3, 4};
// int n = size(arr);
min_reduction(arr, n);
max_reduction(arr, n);
sum_reduction(arr, n);
average_reduction(arr, n);
}

************************************************************************************************************

</pre>
<pre>
<b>Movie Review Classification</b>
<a href="https://github.com/ictdepartment/ictdepartment.github.io/files/11546817/a.txt" download>Jupyter File</a>
<a href="https://github.com/ictdepartment/ictdepartment.github.io/files/11546817/a.txt" download>Dataset</a>
</pre>
<a href="https://github.com/ictdepartment/ictdepartment.github.io/files/11546817/a.txt" download>Download File</a>


</body>
</html>
