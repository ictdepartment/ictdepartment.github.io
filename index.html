<!DOCTYPE html>
<html>
<head>
  <title>My Website</title>
  <script src="script.js"></script>
</head>
<body>
 <pre>

<b>1. ASSIGNMENT1BFS</b>


#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;omp.h&gt;

using namespace std;

void bfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    queue<int> q;
    q.push(node);
    visited[node] = true;

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        cout << "Visited node: " << curr << endl;

        #pragma omp parallel for
        for (int i = 0; i < graph[curr].size(); i++) {
            int neighbor = graph[curr][i];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    int numNodes = 7;
    vector<vector<int>> graph(numNodes);
    vector<bool> visited(numNodes, false);

    // Graph initialization
    graph[0] = {1, 2};
    graph[1] = {3, 4};
    graph[2] = {5};
    graph[3] = {};
    graph[4] = {6};
    graph[5] = {2};
    graph[6] = {};

    int startNode = 0;

    cout << "BFS traversal using OpenMP:" << endl;
    bfs(startNode, graph, visited);

    return 0;
}

*********************************************************************

<b>2. ASSIGNMENT1DFS</b>


#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;omp.h&gt;

using namespace std;

void dfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    stack<int> stk;
    stk.push(node);

    while (!stk.empty()) {
        int curr = stk.top();
        stk.pop();

        if (!visited[curr]) {
            visited[curr] = true;
            cout << "Visited node: " << curr << endl;

            #pragma omp parallel for
            for (int i = 0; i < graph[curr].size(); i++) {
                int neighbor = graph[curr][i];
                stk.push(neighbor);
            }
        }
    }
}

int main() {
    int numNodes = 7;
    vector<vector<int>> graph(numNodes);
    vector<bool> visited(numNodes, false);

    // Graph initialization
    graph[0] = {1, 2};
    graph[1] = {3, 4};
    graph[2] = {5};
    graph[3] = {};
    graph[4] = {6};
    graph[5] = {2};
    graph[6] = {};

    int startNode = 0;

    cout << "DFS traversal using OpenMP:" << endl;
    dfs(startNode, graph, visited);

    return 0;
}

*****************************************************************


<b>3. ASSIGNMENT2BUBBLESORT</b>

#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;omp.h&gt;
using namespace std;
void bubble(int *, int);
void swap(int &, int &);
void bubble(int *a, int n) {
for( int i = 0; i < n; i++ ) {
int first = i % 2;
#pragma omp parallel for shared(a,first)
for( int j = first; j < n-1; j += 2 ) {
if( a[ j ] > a[ j+1 ] ) {
swap( a[ j ], a[ j+1 ] );
}
}
}
}
void swap(int &a, int &b) {
int test;
test=a;
a=b;
b=test;
}
int main() {
int *a,n;
cout<<"\n enter total no of elements=>";
cin>>n;
a=new int[n];
cout<<"\n enter elements=>";
for(int i=0;i<n;i++) {
cin>>a[i];
}
bubble(a,n);
cout<<"\n sorted array is=>";
for(int i=0;i<n;i++) {
cout<<a[i]<<endl;
}
return 0;
}

********************************************************************************

<b>4. ASSIGNMENT2MERGESORT</b>

#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;omp.h&gt;
using namespace std;

void mergesort(int a[], int i, int j);
void merge(int a[], int i1, int j1, int i2, int j2);

void mergesort(int a[], int i, int j) {
    int mid;
    if (i < j) {
        mid = (i + j) / 2;
#pragma omp parallel sections
        {
#pragma omp section
            {
                mergesort(a, i, mid);
            }
#pragma omp section
            {
                mergesort(a, mid + 1, j);
            }
        }
        merge(a, i, mid, mid + 1, j);
    }
}

void merge(int a[], int i1, int j1, int i2, int j2) {
    int temp[1000];
    int i, j, k;
    i = i1;
    j = i2;
    k = 0;
    while (i <= j1 && j <= j2) {
        if (a[i] < a[j]) {
            temp[k++] = a[i++];
        }
        else {
            temp[k++] = a[j++];
        }
    }
    while (i <= j1) {
        temp[k++] = a[i++];
    }
    while (j <= j2) {
        temp[k++] = a[j++];
    }
    for (i = i1, j = 0; i <= j2; i++, j++) {
        a[i] = temp[j];
    }
}

int main() {
    int* a, n, i;
    cout << "\nEnter total number of elements: ";
    cin >> n;
    a = new int[n];
    cout << "\nEnter elements: ";
    for (i = 0; i < n; i++) {
        cin >> a[i];
    }
    mergesort(a, 0, n - 1);
    cout << "\nSorted array is: ";
    for (i = 0; i < n; i++) {
        cout << "\n" << a[i];
    }
    delete[] a;
    return 0;
}




</pre>
<a href="https://github.com/ictdepartment/ictdepartment.github.io/files/11546817/a.txt" download>Download File</a>


</body>
</html>
