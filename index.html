<!DOCTYPE html>
<html>
<head>
  <script>
    function copyText(buttonId, hiddenTextId) {
      // Get the hidden text element
      var hiddenText = document.getElementById(hiddenTextId);

      // Create a textarea element
      var textarea = document.createElement("textarea");

      // Set the value of the textarea to the hidden text
      textarea.value = hiddenText.innerText;

      // Append the textarea to the document
      document.body.appendChild(textarea);

      // Select the contents of the textarea
      textarea.select();

      // Copy the selected text to the clipboard
      document.execCommand("copy");

      // Remove the textarea from the document
      document.body.removeChild(textarea);

      // Alert the user that the text has been copied
      alert("Text has been copied from button: " + buttonId);
    }
  </script>
</head>
<body>
  <button onclick="copyText('button1', 'hiddenText1')">Copy Hidden Text 1</button>
  <button onclick="copyText('button2', 'hiddenText2')">Copy Hidden Text 2</button>
  <button onclick="copyText('button3', 'hiddenText3')">Copy Hidden Text 3</button>
  <button onclick="copyText('button4', 'hiddenText4')">Copy Hidden Text 4</button>

  <div id="hiddenText1" style="display: none;">
    <pre>
#include iostream
#include vector
#include queue
#include omp.h

using namespace std;

void bfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    queue<int> q;
    q.push(node);
    visited[node] = true;

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        cout << "Visited node: " << curr << endl;

        #pragma omp parallel for
        for (int i = 0; i < graph[curr].size(); i++) {
            int neighbor = graph[curr][i];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    int numNodes = 7;
    vector<vector<int>> graph(numNodes);
    vector<bool> visited(numNodes, false);

    // Graph initialization
    graph[0] = {1, 2};
    graph[1] = {3, 4};
    graph[2] = {5};
    graph[3] = {};
    graph[4] = {6};
    graph[5] = {2};
    graph[6] = {};

    int startNode = 0;

    cout << "BFS traversal using OpenMP:" << endl;
    bfs(startNode, graph, visited);

    return 0;
}

    </pre>
  </div>
  <div id="hiddenText2" style="display: none;">
  <pre>
#include iostream
#include vector
#include stack
#include omp.h

using namespace std;

void dfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    stack<int> stk;
    stk.push(node);

    while (!stk.empty()) {
        int curr = stk.top();
        stk.pop();

        if (!visited[curr]) {
            visited[curr] = true;
            cout << "Visited node: " << curr << endl;

            #pragma omp parallel for
            for (int i = 0; i < graph[curr].size(); i++) {
                int neighbor = graph[curr][i];
                stk.push(neighbor);
            }
        }
    }
}

int main() {
    int numNodes = 7;
    vector<vector<int>> graph(numNodes);
    vector<bool> visited(numNodes, false);

    // Graph initialization
    graph[0] = {1, 2};
    graph[1] = {3, 4};
    graph[2] = {5};
    graph[3] = {};
    graph[4] = {6};
    graph[5] = {2};
    graph[6] = {};

    int startNode = 0;

    cout << "DFS traversal using OpenMP:" << endl;
    dfs(startNode, graph, visited);

    return 0;
}

    </pre>
  </div>
  <div id="hiddenText3" style="display: none;">This is the hidden text 3.</div>
  <div id="hiddenText4" style="display: none;">This is the hidden text 4.</div>
</body>
</html>
